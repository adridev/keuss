(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{66:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return s}));var n=a(2),r=a(6),b=(a(0),a(90)),c={id:"concepts",title:"Concepts",sidebar_label:"Concepts"},i={unversionedId:"concepts",id:"concepts",isDocsHomePage:!1,title:"Concepts",description:"Queue",source:"@site/docs/concepts.md",permalink:"/keuss/docs/concepts",editUrl:"https://github.com/pepmartinez/keuss/edit/master/website/docs/concepts.md",sidebar_label:"Concepts",sidebar:"someSidebar",previous:{title:"About",permalink:"/keuss/docs/"},next:{title:"Install",permalink:"/keuss/docs/usage/install"}},l=[],o={rightToc:l};function s(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(b.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(b.b)("h1",{id:"queue"},"Queue"),Object(b.b)("p",null,"a ",Object(b.b)("strong",{parentName:"p"},"Queue")," is more of an interface, a definition of what it can do. Keuss queues are capable of:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"insert one element"),Object(b.b)("li",{parentName:"ul"},"schedule an element: insert one element with a not-before datetime"),Object(b.b)("li",{parentName:"ul"},"get an element, and block for some specified time if no element is available"),Object(b.b)("li",{parentName:"ul"},"reserve an element, and block for some specified time if no element is available"),Object(b.b)("li",{parentName:"ul"},"commit (remove) or rollback (return back) a previously reserved element"),Object(b.b)("li",{parentName:"ul"},"get element count"),Object(b.b)("li",{parentName:"ul"},"get element count whose not-before datetime is in the future (scheduled elements)"),Object(b.b)("li",{parentName:"ul"},"get usage stats: elements inserted, elements extracted")),Object(b.b)("p",null,Object(b.b)("em",{parentName:"p"},"element")," here translates to any js object. Internally, it's usually managed as json"),Object(b.b)("h1",{id:"pipeline"},"Pipeline"),Object(b.b)("p",null,"A ",Object(b.b)("strong",{parentName:"p"},"pipeline")," is an enhanced queue that provides an extra operation: pass an element to another queue ",Object(b.b)("strong",{parentName:"p"},"atomically"),". In an scenario where processors are linked with queues, it is usually a good feature to allow the 'commit element in incoming queue, insert element in the next queue' to be atomic. This removes chances for race conditions, or message losses."),Object(b.b)("p",null,"The pipeline concept is, indeed, an extension of the reserve-commit model; it is so far implemented only atop mongodb, and it is anyway considered as a 'low-level' feature, best used by means of specialized classes to encapsulate the aforementioned processors."),Object(b.b)("h1",{id:"storage"},"Storage"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Storage")," or ",Object(b.b)("strong",{parentName:"p"},"Backend")," provides almost-complete queue primitives, fully functional and already usable as is. Keuss comes with 7 backends, with various levels of features and performance:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"mongo"),", a mongodb-based backend that provides the full set of queue features, still with decent performance."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"redis-oq"),", backed using an ordered queue on top of redis (made in turn with a sorted set, a hash and some lua). Provides all queue features including reserve-commit-rollback. Noticeable faster than mongodb."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"redis-list"),", backed using a redis list. Does not offer reserve-commit-rollback nor the ability to schedule, but is much faster than redis-oq"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"pl-mongo"),", a version of the ",Object(b.b)("em",{parentName:"li"},"mongo")," backend that provides pipelining capabilities (the queues it produces are also pipelines)."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"ps-mongo"),", a version of the ",Object(b.b)("em",{parentName:"li"},"mongo")," backend where elements are not physically deleted from the collection when extracted; instead, they are just marked as processed and later deleted automatically using a mongodb TTL index."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"bucket-mongo"),", a first attepmt on storing more than one element on each mongodb record in order to break past mongodb I/O limitations. It is very simple, lacking schedule and reserve support. However, it has staggering throughput on a reasonable durability."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"bucket-mongo-safe"),", an evolution of bucket-mongo, provides both scheduling and reserve support with a performance only a bit below bucket-mongo")),Object(b.b)("p",null,"As mentioned before, persistence and HA depends exclusively on the underliying system: mongodb provides production-grade HA and persistence while using potentially gigantic queues, and with redis one can balance performance and simplicity over reliability and durability, by using standalone redis, redis sentinel or redis cluster. Keuss uses ",Object(b.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/luin/ioredis"}),"ioredis")," as redis driver, which supports all 3 cases."),Object(b.b)("p",null,"The following table shows the capabilities of each backend:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"backend"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"delay/schedule"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"reserve/commit"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"pipelining"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"history"),Object(b.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"throughput"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"redis-list"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"++++")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"redis-oq"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"+++")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"mongo"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"++")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"pl-mongo"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"+")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ps-mongo"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"++")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"bucket-mongo"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"+++++")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"bucket-mongo-safe"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"x"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"-"),Object(b.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"+++++")))),Object(b.b)("h1",{id:"signaller"},"Signaller"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Signaller")," provides a bus interconnecting all keuss clients, so events can be shared. Keuss provides 3 signallers:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"local")," : provides in-proccess messaging, useful only for simple cases or testing"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"redis-pubsub"),": uses the pubsub subsystem provided by redis"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"mongo-capped"),": uses pubsub on top of a mongodb capped collection, using ",Object(b.b)("a",Object(n.a)({parentName:"li"},{href:"https://www.npmjs.com/package/@nodebb/mubsub"}),"@nodebb/mubsub"))),Object(b.b)("p",null,"So far, the only events published by keuss are:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"element inserted in queue X"),", which allows other clients waiting for elements to be available to wake up and retry. A client will not fire an event if another one of the same type (same client, same queue) was already fired less than 50ms ago"),Object(b.b)("li",{parentName:"ul"},"queue paused/resumed")),Object(b.b)("h1",{id:"stats"},"Stats"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Stats")," provides counters and metrics on queues, shared among keuss clients. The supported stats are:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"elements put"),Object(b.b)("li",{parentName:"ul"},"elements got"),Object(b.b)("li",{parentName:"ul"},"paused status")),Object(b.b)("p",null,"Three options are provided to store the stats:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"mem"),": very simple in-process, memory based."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"redis"),": backed by redis hashes. Modifications are buffered in memory and flushed every 100ms."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"mongo"),": backed by mongodb using one object per queue inside a single collection. Modifications are buffered in memory and flushed every 100ms.")),Object(b.b)("h1",{id:"how-all-fits-together"},"How all fits together"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"Queues"),", or rather clients to individual queues, are created using a ",Object(b.b)("em",{parentName:"li"},"backend")," as factory."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"Backends")," need to be initialized before being used. Exact initialization details depend on each backend."),Object(b.b)("li",{parentName:"ul"},"When creating a ",Object(b.b)("em",{parentName:"li"},"queue"),", a ",Object(b.b)("em",{parentName:"li"},"signaller")," and a ",Object(b.b)("em",{parentName:"li"},"stats")," are assigned to it. The actual class/type to be used can be specified at the queue's creation moment, or at the backend initialization moment. By default ",Object(b.b)("em",{parentName:"li"},"local")," and ",Object(b.b)("em",{parentName:"li"},"mem"),", respectively, are used."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"Queues")," are created on-demand, and are never destroyed as far as keuss is concerned. They do exist as long as the underlying backend kepts them in existence: for example, redis queues dissapear as such when they become empty."),Object(b.b)("li",{parentName:"ul"},Object(b.b)("em",{parentName:"li"},"Pipelines")," are, strictly speaking, just enhanced queues; as such they behave and can be used as a queue. More info on pipelines ",Object(b.b)("a",Object(n.a)({parentName:"li"},{href:"/keuss/docs/usage/pipelines"}),"here"))))}s.isMDXComponent=!0},90:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function b(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){b(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},b=Object.keys(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),s=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,b=e.originalType,c=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),p=s(a),u=n,d=p["".concat(c,".").concat(u)]||p[u]||m[u]||b;return a?r.a.createElement(d,i(i({ref:t},o),{},{components:a})):r.a.createElement(d,i({ref:t},o))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var b=a.length,c=new Array(b);c[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var o=2;o<b;o++)c[o]=a[o];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);